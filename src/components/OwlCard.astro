---
// src/components/OwlCard.astro
export interface Props {
  id: number;
  seed: string;
  likeCount: number;
}

const { id, seed, likeCount } = Astro.props;
---

<div
  class="owl-card relative bg-slate-800/50 border border-slate-700 rounded-lg p-4 flex flex-col items-center gap-4 transition-all duration-300 hover:border-orange-500 hover:bg-slate-800 hover:scale-105"
>
  <!-- Canvas where the owl SVG will be rendered -->
  <div id={`owl-canvas-${id}`} class="w-32 h-36"></div>

  <!-- Owl's name (seed) -->
  <code class="w-full text-center text-sm text-slate-400 truncate" title={seed}
    >{seed}</code
  >

  <!-- Like button -->
  <button
    data-owl-id={id}
    class="like-btn group absolute top-2 right-2 flex items-center gap-1.5 bg-slate-900/50 px-2 py-1 rounded-full border border-transparent hover:border-red-500/50 transition"
  >
    <svg
      class="w-4 h-4 text-slate-500 group-hover:text-red-500 transition"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
      ><path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M4.318 6.318a4.5 4.5 0 016.364 0L12 7.5l1.318-1.182a4.5 4.5 0 116.364 6.364L12 20.25l-7.682-7.682a4.5 4.5 0 010-6.364z"
      ></path></svg
    >
    <span class="like-count text-slate-400 text-xs font-mono">{likeCount}</span>
  </button>
</div>

<script>
  // This script is scoped to each individual card component.
  // It includes the necessary functions to generate the owl SVG.

  // NEW: Converts any string into a consistent 32-bit integer for the generator
  function stringToHash(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash |= 0; // Convert to 32bit integer
    }
    return hash;
  }
  // 1. A seedable random number generator to replace Math.random()
  function mulberry32(a: number) {
    return function () {
      var t = (a += 0x6d2b79f5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function generateOwl(container: HTMLElement, numericSeed: number) {
    const random = mulberry32(numericSeed);

    // --- Procedural Generation Flags ---
    const gender = numericSeed % 2 === 0 ? "Male" : "Female";
    if (!(container instanceof HTMLElement)) {
      return;
    }
    const hasBellyPattern = random() > 0.5; // 50% chance for belly markings
    const hasRune = random() > 0.7; // 30% chance for a forehead rune
    const hasCheekBlush = random() > 0.6; // 40% chance for blush

    container.dataset.owlGender = gender;

    // --- Palettes & Colors ---
    const bodyColors = ["#6b4226", "#4b3621", "#8b5e3c", "#5c4033", "#42342b"];
    const bellyColors = ["#f4e1c1", "#e8d3a8", "#fff2d1", "#f5deb3"];
    const maleEyeColors = ["#fff", "#f9f9f9", "#fffcf2"];
    const femaleEyeColors = ["#fff2d1", "#f5e8d3", "#fff9e3"]; // Softer for females
    const irisColors = ["#2c2c2c", "#3b2f2f", "#1b1b1b", "#4a3c2a"];
    const beakAndFeetColor = "#e09f3e";
    const blushColor = "rgba(224, 122, 95, 0.4)"; // A soft, rosy blush color

    // --- Procedural Values ---
    const eyeSize = random() * 6 + 12;
    const bodyWidthFactor = 0.8 + random() * 0.4;
    const isPuffy = random() > 0.6;
    const owlBodyColor = bodyColors[Math.floor(random() * bodyColors.length)];
    const wingColor = bodyColors[Math.floor(random() * bodyColors.length)];
    const bellyColor = bellyColors[Math.floor(random() * bellyColors.length)];
    const eyeColor = (gender === "Female" ? femaleEyeColors : maleEyeColors)[
      Math.floor(random() * 3)
    ];
    const irisColor = irisColors[Math.floor(random() * irisColors.length)];

    container.dataset.owlColor = owlBodyColor;

    // --- Dynamic Dimensions ---
    const bodyRx = 40 * bodyWidthFactor;
    const bellyRx = 28 * bodyWidthFactor;
    const wingSeparation = 28 * bodyWidthFactor;
    const eyeSeparation = 18 * bodyWidthFactor;
    const earSeparation = 35 * bodyWidthFactor;
    const feetSeparation = 10 * bodyWidthFactor;

    // --- SVG Part Generation ---
    const filterAttribute = isPuffy ? 'filter="url(#puffy-filter)"' : "";

    // RESTORED: Belly pattern logic
    let bellyPatternSvg = "";
    if (hasBellyPattern) {
      const patternType = random() > 0.5 ? "spots" : "stripes";
      const patternColor = owlBodyColor;
      const spotSize = 1.5 + random() * 1;
      if (patternType === "spots") {
        bellyPatternSvg = `
                    <circle cx="${60 - bellyRx * 0.3}" cy="95" r="${spotSize}" fill="${patternColor}" opacity="0.6"/>
                    <circle cx="${60 + bellyRx * 0.3}" cy="95" r="${spotSize}" fill="${patternColor}" opacity="0.6"/>
                    <circle cx="60" cy="105" r="${spotSize}" fill="${patternColor}" opacity="0.6"/>`;
      } else {
        bellyPatternSvg = `
                    <line x1="${60 - bellyRx * 0.5}" y1="95" x2="${60 + bellyRx * 0.5}" y2="95" stroke="${patternColor}" stroke-width="2" opacity="0.6"/>
                    <line x1="${60 - bellyRx * 0.5}" y1="105" x2="${60 + bellyRx * 0.5}" y2="105" stroke="${patternColor}" stroke-width="2" opacity="0.6"/>`;
      }
    }

    const eyelashes =
      gender === "Female"
        ? `<!-- Left Eyelash -->
             <path d="M ${60 - eyeSeparation - eyeSize * 0.7},${60 - eyeSize * 0.5} C ${60 - eyeSeparation - eyeSize},${60 - eyeSize} ${60 - eyeSeparation - eyeSize * 1.3},${60 - eyeSize * 0.8}" stroke="${wingColor}" stroke-width="1.5" fill="none" stroke-linecap="round"/>
             <!-- Right Eyelash (Fixed coordinates) -->
             <path d="M ${60 + eyeSeparation + eyeSize * 0.7},${60 - eyeSize * 0.5} C ${60 + eyeSeparation + eyeSize},${60 - eyeSize} ${60 + eyeSeparation + eyeSize * 1.3},${60 - eyeSize * 0.8}" stroke="${wingColor}" stroke-width="1.5" fill="none" stroke-linecap="round"/>`
        : "";

    // NEW: Forehead rune logic
    let runeSvg = "";
    if (hasRune) {
      const runes = [
        `<circle cx="60" cy="45" r="3" stroke="${wingColor}" stroke-width="1.5" fill="none"/>`, // Circle Rune
        `<path d="M 60 42 L 57 48 L 63 48 Z" fill="${wingColor}"/>`, // Triangle Rune
        `<path d="M 58 42 L 62 48 M 62 42 L 58 48" stroke="${wingColor}" stroke-width="2" stroke-linecap="round"/>`, // 'X' Rune
      ];
      runeSvg = runes[Math.floor(random() * runes.length)];
    }

    // NEW: Cheek blush logic
    const blushSvg = hasCheekBlush
      ? `<ellipse cx="${60 - eyeSeparation - eyeSize * 0.5}" cy="72" rx="5" ry="3" fill="${blushColor}" />
             <ellipse cx="${60 + eyeSeparation + eyeSize * 0.5}" cy="72" rx="5" ry="3" fill="${blushColor}" />`
      : "";

    // --- Final SVG Assembly ---
    const svg = `
<svg viewBox="0 0 120 140" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <radialGradient id="bodyGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="${owlBodyColor}" stop-opacity="0.7" /><stop offset="100%" stop-color="${owlBodyColor}" />
    </radialGradient>
    ${isPuffy ? `<filter id="puffy-filter"><feTurbulence type="fractalNoise" baseFrequency="${0.05 + random() * 0.05}" numOctaves="3" result="turbulence"/><feDisplacementMap in="SourceGraphic" in2="turbulence" scale="${5 + random() * 5}" xChannelSelector="R" yChannelSelector="G"/></filter>` : ""}
  </defs>

  <!-- Body & Wings -->
  <ellipse cx="60" cy="85" rx="${bodyRx}" ry="45" fill="url(#bodyGradient)" ${filterAttribute} />
  <ellipse cx="${60 - wingSeparation}" cy="85" rx="15" ry="30" fill="${wingColor}" transform="rotate(-10 ${60 - wingSeparation} 85)" ${filterAttribute} />
  <ellipse cx="${60 + wingSeparation}" cy="85" rx="15" ry="30" fill="${wingColor}" transform="rotate(10 ${60 + wingSeparation} 85)" ${filterAttribute} />
  
  <!-- Belly & Decorations -->
  <ellipse cx="60" cy="95" rx="${bellyRx}" ry="32" fill="${bellyColor}" opacity="0.9"/>
  ${bellyPatternSvg}
  ${blushSvg}

  <!-- Face -->
  <circle cx="${60 - eyeSeparation}" cy="60" r="${eyeSize}" fill="${eyeColor}" />
  <circle cx="${60 + eyeSeparation}" cy="60" r="${eyeSize}" fill="${eyeColor}" />
  <circle cx="${60 - eyeSeparation}" cy="60" r="${eyeSize / 2}" fill="${irisColor}" />
  <circle cx="${60 + eyeSeparation}" cy="60" r="${eyeSize / 2}" fill="${irisColor}" />
  <!-- NEW: Eye Glints -->
  <circle cx="${60 - eyeSeparation + eyeSize * 0.25}" cy="${60 - eyeSize * 0.25}" r="${eyeSize * 0.15}" fill="white" />
  <circle cx="${60 + eyeSeparation + eyeSize * 0.25}" cy="${60 - eyeSize * 0.25}" r="${eyeSize * 0.15}" fill="white" />

  ${eyelashes}
  
  <polygon points="56,70 64,70 60,78" fill="${beakAndFeetColor}" />

  <!-- Head & Ears -->
  ${runeSvg}
  <polygon points="${60 - earSeparation - 10},50 ${60 - earSeparation},30 ${60 - earSeparation + 5},50" fill="${wingColor}" />
  <polygon points="${60 + earSeparation + 10},50 ${60 + earSeparation},30 ${60 + earSeparation - 5},50" fill="${wingColor}" />

  <!-- Feet -->
  <path d="M${60 - feetSeparation - 5},128 Q${60 - feetSeparation},135 ${60 - feetSeparation + 5},128" stroke="${beakAndFeetColor}" stroke-width="3" fill="none" stroke-linecap="round" />
  <path d="M${60 + feetSeparation - 5},128 Q${60 + feetSeparation},135 ${60 + feetSeparation + 5},128" stroke="${beakAndFeetColor}" stroke-width="3" fill="none" stroke-linecap="round" />
</svg>`;
    container.innerHTML = svg;
  }

  document.addEventListener("astro:page-load", () => {
    // Select all owl cards on the page
    const owlCards = document.querySelectorAll<HTMLElement>(".owl-card");

    owlCards.forEach((card) => {
      // Get the unique data for THIS card
      const canvas = card.querySelector<HTMLElement>('[id^="owl-canvas-"]');
      const likeBtn = card.querySelector<HTMLButtonElement>(".like-btn");
      if (!canvas || !likeBtn || card.dataset.initialized) return; // Prevent re-initialization

      const codeEl = card.querySelector("code");
      if (!codeEl) return;
      const seed = codeEl.textContent;
      if (!seed) return;

      const owlId = likeBtn.dataset.owlId;
      const likeCountSpan =
        likeBtn.querySelector<HTMLSpanElement>(".like-count");

      // 1. Generate the owl SVG for this card
      const numericSeed = stringToHash(seed);
      generateOwl(canvas, numericSeed);

      // 2. Add event listener for the like button
      likeBtn.addEventListener("click", async (e) => {
        e.stopPropagation(); // Prevent card animations from firing
        likeBtn.disabled = true;

        // Add a visual pulse effect
        const heartIcon = likeBtn.querySelector("svg");
        if (heartIcon) {
          heartIcon.classList.add("text-red-500", "animate-ping");
        }

        try {
          // NOTE: For production, use an environment variable for the API URL
          const response = await fetch(
            `https://form-handler-api.onrender.com/owls/${owlId}/like`,
            { method: "POST" }
          );
          if (response.ok) {
            const updatedOwl = await response.json();
            if (likeCountSpan) {
              likeCountSpan.textContent = updatedOwl.like_count;
            }
          }
        } catch (error) {
          console.error("Failed to like owl:", error);
        } finally {
          setTimeout(() => {
            if (heartIcon) {
              heartIcon.classList.remove("animate-ping");
            }
            likeBtn.disabled = false;
          }, 500);
        }
      });

      card.dataset.initialized = "true";
    });
  });
</script>
